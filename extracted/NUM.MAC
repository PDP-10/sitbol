	LIST	; FORCE USER TO SEE WHO WE ARE.
	COMMENT .













			* * *   S I T B O L   * * *

				VERSION   3





	COPYRIGHT STEVENS INSTITUTE OF TECHNOLOGY   1972, 1973

	ALL RIGHT RESERVED.



















;-----------------------;

	IF2 ,<PRINTX SITBOL VERSION 3 - MODULE EDIT NUMBER = 0>

;-----------------------;



TITLE	NUM	--SITBOL NUMERIC ROUTINES--
SUBTTL	LARRY SAMBERG/LSS S.I.T 15 AUG 72

;THIS MODULES CONTAINS ALL ARITHMETIC ROUTINES FOR SITBOL.  IT
;IS BROKEN UP INTO TWO PARTS:
;	1)NUMCOM -- NUMERIC COMPARISON ROUTINES
;		 -- EQ,NE,GE,LE,GT,LT
;		-- REMDR, INTEGER, RANDOM

;	2)NUMOP  -- NUMERIC AND ARITHMETIC OPERATIONS
;		 -- PLUS,MINUS,EXP,MUL,DIV,SUM,DIFF

;THE TWO BUILT-IN FUNCTIONS 'REMDR' AND 'INTEGER' ARE IN
;NUMCOM.


;FIRST MAKE SURE COM IS AROUND
	IFNDEF STACK<
	PRINTX COMPILE COM+NUM
	PASS2
	END
>
	SALL			;FOR CLEAN LISTING


	TWOSEG			;SET-UP FOR HIGHSEGMENT
	RELOC	400000		;HI-SEG

	EXDATA			;DEFINE EXTERNALS

	ASUPPRESS		;PURGE UNWANTED SYMBOLS


	NUMVER==1		;VERSION
	NUMEDT==3		;EDIT

SUBTTL	NUMCOM	--NUMERIC COMPARISON ROUTINES

	FUNC	GE$,2,SE	;START FUNCTION BLOCK FOR 'GE'
GE::	MOVSI	S1,(CAMGE P2,)	;SETUP CORRECT COMPARE.
	JRST	DOCOM		;AND GO DO COMPARE

	FUNC	LE$,2,SE	;FUNCTION BLOCK FOR 'LE'
LE::	MOVSI	S1,(CAMLE P2,)	;COMPARE LESS THAN
	JRST	DOCOM		;AND GO TO COMPARE ROUTINE

	FUNC	GT$,2,SE	;FUNCTION BLOCK FOR 'GT'
GT::	MOVSI	S1,(CAMG P2,)	;COMPARE GT
	JRST	DOCOM

	FUNC	LT$,2,SE	;FBLOK FOR 'LT'
LT::	MOVSI	S1,(CAML P2,)	;LESS THAN
	JRST	DOCOM


	FUNC	EQ$,2,SE	;FBLOK FOR 'EQ'
EQ::	MOVSI	S1,(CAME P2,)	;CHECK FOR EQUALITY
	JRST	DOCOM		;AND TO COMPARE

	FUNC	NE$,2,SE	;FBLOCK FOR 'NE'
NE::	MOVSI	S1,(CAMN P2,)	;CHECK FOR INEQUALITY
	JRST	DOCOM

;DOCOM IS THE ROUTINE THAT DOES THE ACTUALLY CONDITION CHECKING
;ON THE COMPARISON PREDICATES.  IT CALLS 'GTSAM2', JUST TO GET
;LIKE DATA-TYPES WITHOUT REGARD FOR WHAT THEY ARE.

DOCOM:	JSP	QLINK,GTSAM2	;GET LIKE DATA TYPES
	ERROR	15		; CAN'T HAPPEN
	JFCL			;IGNORE INTEGER RETURN
	XCT	S1		;DO THE COMPARISON
	JRST	0(PLINK)	;CONDITION NOT SATISFIED
	JRST	RETNUL		;CONDITION SATISFIED--
				; RETURN A NULL

;GTSAM2--ROUTINE TO CONVERT TWO ARGS ON THE STACK TO THE
;SAME NUMERIC FORM.  AN ATTEMPT IS MADE TO CONVERT TO NUMERIC
;OHTERWISE THEY WILL BE CONVERTED TO REAL.

;CALLING SEQUENCE:	JSP QLINK,GTSAM2
;			  ERROR RETURN
;			  INTEGER RETURN
;			  REAL RETURN

;ON RETURN:	P2 CONTAINS FIRST ARGUMENT
;		Z  CONTAINS SECOND ARGUMENT
;		S2 CONTAINS A DESCRIPTOR HEADER FOR THE RESULT.
;	     ***STACK IS POP'ED***

GTSAM2:	CLEAR	Z,		;A LOOP FLAG
	MOVE	S2,-1(STACK)	;GET TYPE OF SECOND ARG
GTSAM3:	AND	S2,-3(STACK)	;AND IT WITH FIRST TYPE
	MOVEM	QLINK,IGNOP	;SAVE THIS
	TLNN	S2,NUMDC	;BOTH NUMERIC?
	JRST	GTSM2A		;NO--MAKE THEM BOTH REAL
	TLNE	S2,IDT-NUMDC	;BOTH INTEGERS?
	JRST	GOTINT		;YES
	TLNE	S2,RDT-NUMDC	;BOTH REAL?
	JRST	GOTRL		;YES GO HANDLE IT
	SKIPE	Z		;FIRST TIME THRU
	JRST	GTSAM4		;NO, GO TO REAL
GTSM2A:	JSP	TLINK,CVTNUM##	;CONVERT SECOND ARG TO NUMERIC
	ERROR.	1,28		; BAD 2ND ARG
	POP	STACK,S3	;POP OFF SECOND ARG
	POP	STACK,S2	;GET THE DESCRIPTOR
	JSP	TLINK,CVTNUM	;CONVERT FIRST ARG TO NUMERIC
	ERROR.	1,27		; BAD 1ST ARG
	PUSH	STACK,S2	;PUT SECOND ARG BACK ON
	PUSH	STACK,S3	;STACK, AND
	SETO	Z,		;SET SECOND TIME AROUND
	MOVE	QLINK,IGNOP	;RESTORE QLINK
	JRST	GTSAM3		;AND TRY AGAIN


GTSAM4:	JSP	TLINK,CVTRL##	;TRY TO GO TO REAL
	  JRST	0(QLINK)	;NO CONVERSION
	POP	STACK,S3	;POP OFF SEC ARG
	POP	STACK,S2
	JSP	TLINK,CVTRL	;AND CONVERT FIRST ARG
	  JRST	0(QLINK)	;CAN'T CONVERT
	MOVE	Z,S3		;SECOND ARG IN Z
	MOVE	QLINK,IGNOP	;RESTORE QLINK
	AOJ	QLINK,		;DOUBLE SKIP MEANS AOS ONCE AND THEN
	AOJA	QLINK,GOTFST	;AOS QLINK AND FINISH THE JOB

GOTRL:	AOJ	QLINK,		;SKIP RETURN
GOTINT:	AOJ	QLINK,		;FOR INTEGER RETUNR
	POP	STACK,Z		;SECOND ARG IN Z
	POP	STACK,S2	;DESCRIPTOR IN S2
GOTFST:	POP	STACK,P2	;FIRST ARG IN P2
	POP	STACK,(STACK)	;CLEAR THE STACK
	JRST	0(QLINK)	;AND TAKE INTEGER RETURN

;HERE ARE THE 'REMDR' AND 'INTEGER' BUILT INS
; AND ALSO 'RANDOM'

	FUNC	REMDR$,2,SE
REMDR::	JSP	TLINK,CVTINT##	;CONVERT SEC ARG TO INT
	ERROR.	1,84		;CAN'T DO
	POP	STACK,P2	;GET SEC ARG IN P2
	POP	STACK,(STACK)	;AND FORGET THIS
	JSP	TLINK,CVTINT	;CONVERT FIRST ARG TO INT
	ERROR.	1,85
	POP	STACK,S2	;GET FIRST ARG IN S2
	SKIPN	P2		;CANT DIV BY ZERO
	ERROR	10,15
	IDIV	S2,P2		;DO THE DIVIDE
	MOVSI	S2,IDT		;INTEGER
	MOVEM	S2,(STACK)	;PUT ON STACK
	PUSH	STACK,S2+1	;STACK THE REMAINDER
	JRST	1(PLINK)	;AND RETURN

	FUNC	INTGR$,1,SE
INTGR::	JSP	TLINK,CVTNUM##	;MAKE SURE ITS NUMERIC
	JRST	FRET1		;ITS NOT -- FAIL
REPEAT 0,<		; NEW CODE THAT IS CORRECT
	HLRZ	Q1,-1(STACK)	;GET DATATYPE
	CAIE	Q1,IDT		;IS IT INTEGER?
	JRST	FRET1		;NO--FAIL
	JRST	RETNL1		;YES--SUCCEED AND RETURN THE NULL
>
;*** Temproary patch 4/10/75 by /DRH
	JRST	PAT001##	;[***] go do above stuff in patch code

	FUNC	RAND$,1,ES
	 ;
	JSP	TLINK,CVTINT	; ENSURE AN
	ERROR.	1,82		; INTEGER
	 ;
	 ; GENERATOR OBTAINED FROM JACM 14:1,110
	 ;
	AOSG	S2,$RAND##	; PICK UP OLD...
	MOVEI	S2,1		; + 1
	IMUL	S2,[273673163155]	; APPLY MULTIPLIER
	MOVEM	S2,$RAND	; SAVE RESULT
	 ;
	LSH	S2,1		; REMOVE SIGN
	MOVEI	S1,200		; NO POWER OF 2
	LSHC	S1,-9		; SHIFT EXPONENT IN
	FSC	S1,0		; AND NORMALIZE
	 ;
	SKIPE	0(STACK)	; REQUESTED REAL?
	JRST	RANDI		; NO, INTEGER
	 ;
	MOVSI	Q1,RDT		; INDICATE ...
	MOVEM	Q1,-1(STACK)	; DATATYPE
	MOVEM	S2,0(STACK)	; SET VALUE
	JRST	1(PLINK)	; AND RETURN

RANDI:	 ; HERE TO PRODUCE AN INTEGER
	 ;
	SKIPL	0(STACK)	; TEST FOR NEG ARG
	JSP	TLINK,CVTRL	; MAKE A REAL
	ERROR	13,47		; FAIL RET CAN'T HAPPEN
	 ;
	FMPL	S2,0(STACK)	; DO THE MULTIPLY
	MOVEM	S2,0(STACK)	; STORE RESULT ON STACK
	JSP	TLINK,CVTINT	; MAKE AN INTEGER
	ERROR	13,47		; THIS WON'T HAPPEN
	 ;
	AOS	0(STACK)	; NEED 1 MORE
	JRST	1(PLINK)	; AND RETURN

SUBTTL	NUMOP	ARITHMETIC OPERATIONS


;FIRST THE BINARY OPERATIONS

;SUM,DIFF,MUL,DIV,EXP


;ADDITION
	FUNC	SUM$,2,SE	;START FBLOK FOR SUM
SUM::	JSP	QLINK,GTSAM2	;GET LIKE DATA TYPES
	ERROR	15		; CAN'T HAPPEN
	JRST	SUMINT		;AND TWO INTEGER

SUMRL:	JFCL	17,.+1		;CLEAR ALL FLAGS
	MOVE	T1,[ERROR (10,2)]
	FADR	P2,Z		;DO THE ADD
	JRST	BINRET		;COMMON BIN OP RETURN

SUMINT:	JFCL	17,.+1		;CLEAR ALL FLAGS
	MOVE	T1,[ERROR (10,7)]
	ADD	P2,Z		;AND THEM
	JRST	BINRET		;AND RETURN


;SUBTRACTION
	FUNC	DIFF$,2,SE	;NEXT COMES SUBTRACTION
DIFF::	JSP	QLINK,GTSAM2	;GET A MATCHED SET
	ERROR	15		; CAN'T HAPPEN
	JRST	DIFINT		;INTEGERS

DIFRL:	JFCL	17,.+1		;CLEAR ALL FLAGS
	MOVE	T1,[ERROR (10,2)]
	FSBR	P2,Z		;SUBTACT THEM
	JRST	BINRET		;AND RETURN

DIFINT:	JFCL	17,.+1		;CLEAR ALL FLAGS
	MOVE	T1,[ERROR (10,8)]
	SUB	P2,Z		;SUBTRACT THEM
	JRST	BINRET

;MULTIPLICATION
	FUNC	MUL$,2,SE
MUL::	JSP	QLINK,GTSAM2	;GET LIKE DATA TYPES
	ERROR	15		; CAN'T HAPPEN
	JRST	MULINT		;INTEGERS

MULRL:	JFCL	17,.+1	;CLEAR ALL FLAGS
	MOVE	T1,[ERROR (10,2)]
	FMPR	P2,Z		;DO THE MULTIPLY
	JRST	BINRET		;AND RETURN

MULINT:	JFCL	17,.+1		;CLEAR FLAGS
	MOVE	T1,[ERROR (10,9)]
	IMUL	P2,Z		;DO THE MULTIPLY
	JRST	BINRET


;DIVISION
	FUNC DIV$,2,SE
DIV::	JSP	QLINK,GTSAM2	;GET LIKE DATATYPES
	ERROR	15		; CAN'T HAPPEN
	JRST	DIVINT

DIVRL:	SKIPN	Z		;IS  DIVISOR ZERO?
	ERROR	10,3		;YES
	JFCL	17,.+1
	MOVE	T1,[ERROR (10,2)]
	FDVR	P2,Z		;DO THE DIVIDE
	JRST	BINRET

DIVINT:	SKIPN	Z		;IS DIVISOR ZERO?
	ERROR	10,6		;YES
	JFCL	17,.+1
	MOVE	T1,[ERROR (10,6)]	;THIS SHOULDN'T HAPPEN
	IDIV	P2,Z		;DIVIDE
	JRST	BINRET

;NOW THE EXPONENTIATION ROUTINE
;COMMENTS REFER TO  A ** B
;USING THIS ALGORITHM, THE NUMBER OF MULTIPLICATIONS
;IS LESS THAN 2LOG(2) B

	FUNC	EXP$,2,SE

EXP::	JSP	TLINK,CVTINT	;CONVERT B TO INTEGER
	ERROR.	1,30		; BAD ARG
	POP	STACK,NUMSTR	;GET B
	POP	STACK,(STACK)	;IGNORE THIS

EXP1:	JSP	TLINK,CVTNUM	;CONVERT A TO NUMERIC
	ERROR.	1,29		;HE LOSES
	POP	STACK,S1	;A GOES IN S1
	POP	STACK,S3	;ITS DESCRIPTOR IN S3
	MOVEI	S2,1		;SETUP FOR MULTIPLY
	TLNE	S3,RDT-NUMDC	;REAL?
	MOVSI	S2,201400	;YES MAKE IT 1.0

EXP2:	MOVE	Q1,NUMSTR	;GET B BACK
	JFFO	Q1,EXP2A	;GET HIGH ORDER BIT OF B
	JRST	EXPZR		;A ** 0 = 1
EXP2A:	TLNE	S3,RDT-NUMDC	;IS A REAL?
	CAME	S1,[201400,,0]	;YES COMPARE AGAINST 1.0
	CAIN	S1,1		;IF INTEGER COMPARE AGAINST 1
	JRST	EXPZR		;1 ** X = 1
	MOVEI	P2,1		;SETUP A MARKER
	MOVNS	Q2		;NEG NUMBER OF LEADING ZEROES
	ADDI	Q2,^D35		;PLUS 35
	LSH	P2,(Q2)		;SETUP A MARKER
	MOVEI	Q2,1		;AND A CURSOR

EXP3:	JFCL	17,.+1		;CLEAR ALL FLAGS
EXP30:	CAMN	P2,Q2		;DONE YET?
	JRST	EXPDON		;YES FINISH UP
	TLNE	S3,RDT-NUMDC	;A REAL?
	JRST	EXP4		;YES! USE FMPR'S
	TDNE	Q1,Q2		;IS CURRENT BIT 1?
	IMUL	S2,S1		;YES! SAVE THIS ONE
	IMUL	S1,S1		;AND SQUARE THIS
	JRST	EXP3A		;SETUP FOR NEXT LOOP

EXP4:	TDNE	Q1,Q2		;IS CURRENT BIT A 1?
	FMPR	S2,S1		;YES SAVE THIS MUL
	FMPR	S1,S1		;AND SQUARE THIS

EXP3A:	LSH	Q2,1		;SETUP CURSOR FOR NEXT BIT
	JOV	[ERROR (10,5)]	;OVERFLOW?
	JRST	EXP30		;GO BACK FOR MORE

;MORE EXPONENTIATION

EXPDON:	JFCL	17,.+1		;CLEAR ALL FLAGS
	TLNE	S3,RDT-NUMDC	;IS A REAL?
	JRST	EXPDN1		;YES
	IMUL	S2,S1		;FINAL PRODUCT
	JRST	EXPRET		;STACK AND RETURN

EXPDN1:	FMPR	S2,S1		;FINAL REAL PRODUCT

EXPRET:	JOV	[ERROR (10,5)]	;OVERFLOW?
	PUSH	STACK,S3	;PUSH THE DESCRIPTOR
	PUSH	STACK,S2	;AND THE ANSWER
	JRST	1(PLINK)	;AND RETURN

EXPZR:	MOVEI	S2,1		;ANSWER IS 1
	TLNE	S3,RDT-NUMDC	;IF A IS REAL,
	MOVSI	S2,201400	;ITS 1.0
	JRST	EXPRET+1	;AND RETURN

;HERE ARE THE TWO UNARY ROUTINES PLUS AND MINUS

	FUNC PLUS$,1,SE
PLUS::	JSP	TLINK,CVTNUM	;CONVERT ARG TO NUMERIC
	ERROR.	1,33		;CONVERSION FAILED
	JRST	1(PLINK)	;RETURN


	FUNC MINUS$,1,SE
MINUS::	JSP	TLINK,CVTNUM	;CONVERT TO NUMERIC
	ERROR.	1,34		;CAN'T CONVERT
	MOVE	P2,0(STACK)	;GET THE VALUE
	CAMN	P2,[400000,,0]	;IF LARGEST NEGATIVE NUMBER,
	ERROR	10,14		;THEN WE CAN'T CONVERT
	MOVNM	P2,0(STACK)	;TAKE THE NEGATIVE
	JRST	1(PLINK)	;AND RETURN

;COMMON RETURN FOR ALL BINARY OPERATIONS

BINRET:	JOV	.+2		;SKIP IF OVERFLOW SET
	SKIPA			;SKIP ERROR JUMP
	JRST	T1		;JUMP TO ERROR ALREADY SETUP IN T1

	PUSH	STACK,S2	;PUT THE DESCRIPTOR ON THE STACK
	PUSH	STACK,P2	;PUT RESULT ON STACK
	JRST	1(PLINK)	;AND RETURN NORMALLY




	RELOC		;DOWN TO LOWSEG
NUMSTR:	BLOCK	1		;SAVE AREA
	RELOC			;BACK TO HISEG


NUMEND:	END
